package bk.devoxx17.emulators;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Map;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.google.common.collect.Maps;

import bk.devoxx17.emulators.databases.DatabaseSQL;
import bk.devoxx17.front.InjectionMethod;
import bk.devoxx17.test.DatabaseSQLHelper;
import bk.devoxx17.test.MaliciousUserInputDictionnary;
import bk.devoxx17.test.MaliciousUserInputDictionnary.UserInput;

public abstract class AbstractVulnerabilityEmulatorTest {

	private static MaliciousUserInputDictionnary dictionnary = new MaliciousUserInputDictionnary();
	protected VulnerabilityEmulator 	emulator;
	protected InjectionMethod 			breakingMethod;
	
	@Test
	public void testCheck_Ok() {
		UserInput input = dictionnary.get(breakingMethod);
		assertTrue(breakingMethod+ " should work", emulator.check(input.login, input.password));
	}
	
	@Test
	public void testCheck_Ko() {
		Map<InjectionMethod, UserInput> tmpDictionnary = dictionnary.newCopy();
		tmpDictionnary.remove(breakingMethod);
		for (Map.Entry<InjectionMethod, UserInput> input : tmpDictionnary.entrySet()) {
			InjectionMethod method 	= input.getKey();
			String login 			= input.getValue().login;
			String password 		= input.getValue().password;
			boolean result			= emulator.check(login, password);
			System.out.println(method + ": " + login + " - " + password +"="+result);
			assertFalse(method+" should not work", result);
		}
	}

}
