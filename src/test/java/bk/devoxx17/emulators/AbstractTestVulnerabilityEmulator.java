package bk.devoxx17.emulators;

import static org.junit.Assert.assertTrue;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.EnumUtils;
import org.apache.commons.lang3.StringUtils;
import org.junit.Test;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;

import bk.devoxx17.front.ApplicationScope;
import bk.devoxx17.front.InjectionMethod;
import bk.devoxx17.test.MaliciousUserInputDictionnary;
import bk.devoxx17.test.MaliciousUserInputDictionnary.UserInput;

public abstract class AbstractTestVulnerabilityEmulator {
	
	private static MaliciousUserInputDictionnary dictionnary = new MaliciousUserInputDictionnary();
	protected VulnerabilityEmulator 	emulator;
	protected InjectionMethod 			breakingMethod;
	
	@Test
	public void testCheck_Ok() {
		Collection<UserInput> inputs = dictionnary.get(breakingMethod);
		for (UserInput input : inputs) {
			check(true, breakingMethod, input, dictionnary.newCopy());
		}
	}
	
	@Test
	public void testCheck_Ko() {
		ArrayListMultimap<InjectionMethod, UserInput> tmpDictionnary = dictionnary.newCopy();
		tmpDictionnary.removeAll(breakingMethod);
		if (EnumUtils.isValidEnum(InjectionMethod.class, breakingMethod.name()+"_DELUXE")) {
			tmpDictionnary.removeAll(InjectionMethod.valueOf(breakingMethod.name()+"_DELUXE"));
		}
		for (Map.Entry<InjectionMethod, UserInput> input : tmpDictionnary.entries()) {
			check(false, input.getKey(), input.getValue(), tmpDictionnary);
		}
	}
	
	protected void check(boolean result, String message) {
		assertTrue(message, result);
	}
	
	private void check(boolean trueOrFalse, InjectionMethod method, UserInput input, ArrayListMultimap<InjectionMethod, UserInput> tmpDictionnary) {
		String login 			= input.login;
		String password 		= input.password;
		Integer index 			= input.index;
		Integer stepnb			= input.stepnb;
		if (stepnb==null) {
			check(trueOrFalse==emulator.check(login, password), emulator.getClass().getSimpleName()+"/"+method+"_"+index+ " should "+ (trueOrFalse?"":"not ") +"work");
		}else if (stepnb==1) {
			List<UserInput> steps = Lists.newArrayList();
			for (UserInput minput : tmpDictionnary.get(method)) {
				if (index.equals(minput.index)) {
					steps.add(minput);
				}
			}
			login = steps.get(0).login;
			password = steps.get(0).password;
			emulator.check(login, password);
			String step1data = getCompromisedData(ApplicationScope.getInstance().getErrorMessage());
			login = steps.get(1).login.replace("step1", step1data);
			password = steps.get(1).password.replace("step1", step1data);
			emulator.check(login, password);
			String step2data = getCompromisedData(ApplicationScope.getInstance().getErrorMessage());
			login = steps.get(2).login.replace("step1", step1data).replace("step2", step2data);
			password = steps.get(2).password.replace("step1", step1data).replace("step2", step2data);
			check(trueOrFalse==emulator.check(login, password), emulator.getClass().getSimpleName()+"/"+method+"_"+index+ " should " + (trueOrFalse?"":"not ") + "work");
		}
	}
	
	private String getCompromisedData(String errorMessage) {
		if (errorMessage.indexOf('\'')==-1) {
			return StringUtils.EMPTY;
		}
		return errorMessage.substring(errorMessage.indexOf('\'')+1, errorMessage.lastIndexOf('\''));
	}
}
