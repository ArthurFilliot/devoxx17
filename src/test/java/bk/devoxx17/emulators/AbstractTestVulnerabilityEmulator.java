package bk.devoxx17.emulators;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.EnumUtils;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;

import bk.devoxx17.emulators.databases.DatabaseSQL;
import bk.devoxx17.front.InjectionMethod;
import bk.devoxx17.test.DatabaseSQLHelper;
import bk.devoxx17.test.MaliciousUserInputDictionnary;
import bk.devoxx17.test.MaliciousUserInputDictionnary.UserInput;

public abstract class AbstractTestVulnerabilityEmulator {

	private static MaliciousUserInputDictionnary dictionnary = new MaliciousUserInputDictionnary();
	protected VulnerabilityEmulator 	emulator;
	protected InjectionMethod 			breakingMethod;
	
	@Test
	public void testCheck_Ok() {
		List<UserInput> inputs = dictionnary.get(breakingMethod);
		for (UserInput input : inputs) {
			assertTrue(breakingMethod+ "_" + input.index + " should work", emulator.check(input.login, input.password));
		}
	}
	
	@Test
	public void testCheck_Ko() {
		Multimap<InjectionMethod, UserInput> tmpDictionnary = dictionnary.newCopy();
		tmpDictionnary.removeAll(breakingMethod);
		if (EnumUtils.isValidEnum(InjectionMethod.class, breakingMethod.name()+"_DELUXE")) {
			tmpDictionnary.removeAll(InjectionMethod.valueOf(breakingMethod.name()+"_DELUXE"));
		}
		for (Map.Entry<InjectionMethod, UserInput> input : tmpDictionnary.entries()) {
			InjectionMethod method 	= input.getKey();
			String login 			= input.getValue().login;
			String password 		= input.getValue().password;
			boolean result			= emulator.check(login, password);
			System.out.println(method + ": " + login + " - " + password +"="+result);
			assertFalse(method+" should not work", result);
		}
	}

}
