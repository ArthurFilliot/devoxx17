package bk.devoxx17.emulators;

import static org.junit.Assert.assertTrue;

import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.EnumUtils;
import org.junit.Test;

import com.google.common.collect.Multimap;

import bk.devoxx17.front.InjectionMethod;
import bk.devoxx17.test.MaliciousUserInputDictionnary;
import bk.devoxx17.test.MaliciousUserInputDictionnary.UserInput;

public abstract class AbstractTestVulnerabilityEmulator {
	
	private static MaliciousUserInputDictionnary dictionnary = new MaliciousUserInputDictionnary();
	protected VulnerabilityEmulator 	emulator;
	protected InjectionMethod 			breakingMethod;
	
	protected void check(boolean result, String message) {
		assertTrue(message, result);
	}
	
	@Test
	public void testCheck_Ok() {
		List<UserInput> inputs = dictionnary.get(breakingMethod);
		for (UserInput input : inputs) {
			check(emulator.check(input.login, input.password), emulator.getClass().getSimpleName()+"/"+breakingMethod+"_"+input.index+ " should work");
		}
	}
	
	@Test
	public void testCheck_Ko() {
		Multimap<InjectionMethod, UserInput> tmpDictionnary = dictionnary.newCopy();
		tmpDictionnary.removeAll(breakingMethod);
		if (EnumUtils.isValidEnum(InjectionMethod.class, breakingMethod.name()+"_DELUXE")) {
			tmpDictionnary.removeAll(InjectionMethod.valueOf(breakingMethod.name()+"_DELUXE"));
		}
		for (Map.Entry<InjectionMethod, UserInput> input : tmpDictionnary.entries()) {
			InjectionMethod method 	= input.getKey();
			String login 			= input.getValue().login;
			String password 		= input.getValue().password;
			Integer index 			= input.getValue().index;

			boolean result			= emulator.check(login, password);
			System.out.println(method + ": " + login + " - " + password +"="+result);
			check(!emulator.check(login, password), emulator.getClass().getSimpleName()+"/"+method+"_"+index+ " should not work");
		}
	}
}
